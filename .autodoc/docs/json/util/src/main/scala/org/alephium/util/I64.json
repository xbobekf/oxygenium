{
  "fileName": "I64.scala",
  "filePath": "util/src/main/scala/org/alephium/util/I64.scala",
  "url": "https://github.com/alephium/alephium/util/src/main/scala/org/alephium/util/I64.scala",
  "summary": "The code defines a class `I64` and an object `I64` in the `org.alephium.util` package. The `I64` class represents a 64-bit signed integer and provides methods for arithmetic operations such as addition, subtraction, multiplication, division, and modulo. The `I64` object provides utility methods for creating instances of the `I64` class from various types of input.\n\nThe `I64` class is defined as a value class, which means that it is optimized for performance and memory usage. The `v` field of the `I64` class holds the underlying `Long` value of the 64-bit integer. The `isZero` method returns `true` if the `v` field is equal to zero. The `isPositive` method returns `true` if the `v` field is greater than or equal to zero.\n\nThe `addUnsafe`, `add`, `subUnsafe`, `sub`, `mulUnsafe`, `mul`, `divUnsafe`, `div`, `modUnsafe`, and `mod` methods perform arithmetic operations on two `I64` instances. The `Unsafe` methods assume that the result of the operation will not overflow or underflow the 64-bit integer range, while the non-`Unsafe` methods return an `Option[I64]` that is `Some(result)` if the operation does not overflow or underflow, and `None` otherwise. The `compare` method compares two `I64` instances and returns an `Int` that is negative, zero, or positive depending on whether the first instance is less than, equal to, or greater than the second instance.\n\nThe `toBigInt` method returns a `BigInteger` representation of the `I64` instance.\n\nThe `I64` object provides several utility methods for creating instances of the `I64` class. The `from` method creates an `I64` instance from a `Long` value. The `validate` method returns `true` if a `BigInteger` value can be safely converted to an `I64` instance. The `from` method that takes a `BigInteger` value returns an `Option[I64]` that is `Some(result)` if the value can be safely converted, and `None` otherwise. The `fromU64`, `fromI256`, and `fromU256` methods create an `I64` instance from a `U64`, `I256`, or `U256` instance, respectively.\n\nThe `I64` object also provides several constants that represent common `I64` values, such as `Zero`, `One`, `Two`, `NegOne`, `MinValue`, and `MaxValue`.\n\nThe `checkAdd`, `checkSub`, `checkMul`, and `checkDiv` methods are private utility methods that check whether an arithmetic operation will overflow or underflow the 64-bit integer range. These methods are used by the `Unsafe` and non-`Unsafe` arithmetic methods to ensure that the result of the operation is within the 64-bit integer range.",
  "questions": "1. What is the purpose of the `I64` class?\n- The `I64` class is a wrapper around a `Long` value that provides methods for performing arithmetic operations and comparisons on `Long` values.\n\n2. What is the purpose of the `from` methods in the `I64` object?\n- The `from` methods in the `I64` object are factory methods for creating instances of the `I64` class from various types of input values, such as `Long`, `BigInteger`, `U64`, `I256`, and `U256`.\n\n3. What is the purpose of the `checkAdd`, `checkSub`, `checkMul`, and `checkDiv` methods in the `I64` object?\n- The `checkAdd`, `checkSub`, `checkMul`, and `checkDiv` methods in the `I64` object are private helper methods used to check for overflow and underflow conditions when performing arithmetic operations on `Long` values."
}