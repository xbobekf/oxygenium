{
  "folderName": "tools",
  "folderPath": ".autodoc/docs/json/tools/src/main/scala/org/alephium/tools",
  "url": "https://github.com/alephium/alephium/.autodoc/docs/json/tools/src/main/scala/org/alephium/tools",
  "files": [
    {
      "fileName": "BuiltInFunctions.scala",
      "filePath": "tools/src/main/scala/org/alephium/tools/BuiltInFunctions.scala",
      "url": "https://github.com/alephium/alephium/tools/src/main/scala/org/alephium/tools/BuiltInFunctions.scala",
      "summary": "The `BuiltInFunctions` object is a tool used to generate a JSON file containing information about the built-in functions in the Alephium protocol. The JSON file is generated by extracting information from the `BuiltIn` object, which contains all the built-in functions in the protocol. The extracted information is then formatted into a `FunctionInfo` case class, which contains the name, category, signature, documentation, parameters, and return type of each function. \n\nThe `FunctionInfo` case class is defined with an implicit `ReadWriter` using the `upickle` library, which allows for easy serialization and deserialization of the case class to and from JSON. The `ordering` implicit value is also defined for the `FunctionInfo` case class, which is used to sort the functions by category when writing to the JSON file. \n\nThe `allFunctions` value is defined as an immutable iterable of `FunctionInfo` objects, which is generated by mapping over the `statefulFuncsSeq` sequence in the `BuiltIn` object. The `statefulFuncsSeq` sequence contains all the built-in functions in the protocol, along with their metadata. The `map` function extracts the relevant metadata from each function and formats it into a `FunctionInfo` object. \n\nThe `json` value is defined as a string representation of the `allFunctions` iterable, which is serialized to JSON using the `upickle` library. The JSON string is then written to a file located at `../protocol/src/main/resources/ralph-built-in-functions.json` using a `PrintWriter`. \n\nThis tool is useful for generating documentation for the built-in functions in the Alephium protocol. The generated JSON file can be used by other tools to provide information about the functions to users, such as an IDE or a web-based documentation tool. \n\nExample usage:\n```scala\nimport org.alephium.tools.BuiltInFunctions\n\n// Generate JSON file containing built-in function information\nBuiltInFunctions.main(Array())\n```",
      "questions": "1. What is the purpose of this code?\n   - This code generates a JSON file containing information about built-in functions in the Alephium project and writes it to a specific location.\n\n2. What is the format of the JSON file generated by this code?\n   - The JSON file contains an array of objects, where each object represents a built-in function and contains information such as its name, category, signature, documentation, parameters, and return type.\n\n3. What is the significance of the `BuiltInFunctions` object and the `FunctionInfo` case class?\n   - The `BuiltInFunctions` object contains the main logic for generating the JSON file, while the `FunctionInfo` case class defines the structure of the objects that will be included in the JSON array."
    },
    {
      "fileName": "DBV110ToV100.scala",
      "filePath": "tools/src/main/scala/org/alephium/tools/DBV110ToV100.scala",
      "url": "https://github.com/alephium/alephium/tools/src/main/scala/org/alephium/tools/DBV110ToV100.scala",
      "summary": "This code is a Scala script that performs a database migration from version 1.1.0 to version 1.0.0 for the Alephium project. The migration is necessary because the database schema has changed between these two versions, and the script ensures that the data is correctly migrated to the new schema.\n\nThe script uses the RocksDB database engine to access the database. It first defines the path to the database file, which is located in the user's home directory under the `.alephium/mainnet` folder. It then defines two column family names, `Broker` and `All`, which are used to access specific parts of the database.\n\nThe script then defines the keys and values that are used to store the database version information. The `dbVersionKey` is a byte array that represents the key used to store the version information in the database. The `dbVersion100` and `dbVersion110` byte arrays represent the version information for versions 1.0.0 and 1.1.0, respectively. These byte arrays are serialized using the `serialize` method from the `org.alephium.serde` package.\n\nThe script then creates a `RocksDBSource` object using the `createRocksDBUnsafe` method from the `org.alephium.flow.io.Storages` object. This object is used to access the database and its column families.\n\nThe script then iterates over the column families in the database using the `cfHandles` property of the `RocksDBSource` object. For each column family, it checks if the `databaseVersion` key has the value `dbVersion110`. If it does, it drops the `Broker` column family and sets the `databaseVersion` key to the value `dbVersion100`.\n\nThis script is intended to be run as a standalone application using the `sbt run` command. It is used as part of the Alephium project to ensure that the database schema is correctly migrated between versions.",
      "questions": "1. What is the purpose of this code?\n   \n   This code is used to migrate a database from version 1.1.0 to version 1.0.0 in the Alephium project.\n\n2. What dependencies does this code have?\n   \n   This code has dependencies on the Akka library, the Alephium project's own libraries, and the RocksDB library.\n\n3. What is the expected input and output of this code?\n   \n   The expected input is a database in version 1.1.0, and the expected output is a database in version 1.0.0 with the broker column family dropped."
    },
    {
      "fileName": "MiningRewards.scala",
      "filePath": "tools/src/main/scala/org/alephium/tools/MiningRewards.scala",
      "url": "https://github.com/alephium/alephium/tools/src/main/scala/org/alephium/tools/MiningRewards.scala",
      "summary": "The `MiningRewards` object is a tool that calculates the inflation rate of the Alephium cryptocurrency based on different parameters. The inflation rate is the rate at which the total supply of a cryptocurrency increases over time. The tool calculates the inflation rate based on the hashrate of the network and the number of years since the network's inception.\n\nThe tool imports several classes from the Alephium project, including `ALPH`, `GroupConfig`, `Emission`, `Duration`, `Number`, and `U256`. These classes are used to define the parameters needed to calculate the inflation rate.\n\nThe `MiningRewards` object defines a `groupConfig` object, which specifies the number of groups in the network. It also defines a `blockTargetTime` object, which specifies the target time for each block to be mined. These parameters are used to calculate the `emission` object, which represents the total amount of new coins that will be created over time.\n\nThe `calInflation` method is a private method that takes a `yearlyReward` parameter and calculates the inflation rate based on that reward. The method converts the `yearlyReward` to a `BigDecimal` and divides it by one billion to get the inflation rate as a percentage.\n\nThe `printLine` method is a helper method that prints a string to the console with a newline character at the end.\n\nThe `emission.rewardsWrtTarget()` method calculates the inflation rate based on the hashrate of the network. It returns a list of tuples, where each tuple contains the hashrate and the yearly reward. The tool then iterates over this list and calculates the inflation rate for each tuple using the `calInflation` method. It then prints the hashrate, inflation rate, and yearly reward to the console.\n\nThe `emission.rewardsWrtTime()` method calculates the inflation rate based on the number of years since the network's inception. It returns a list of tuples, where each tuple contains the year and the yearly reward. The tool then iterates over this list and calculates the inflation rate for each tuple using the `calInflation` method. It then prints the year, inflation rate, and yearly reward to the console.\n\nOverall, the `MiningRewards` object is a useful tool for developers working on the Alephium project who need to calculate the inflation rate of the cryptocurrency based on different parameters. The tool can be used to optimize the network's parameters to achieve a desired inflation rate.",
      "questions": "1. What is the purpose of this code?\n   - This code calculates the inflation rate of the Alephium cryptocurrency based on hash rate and time.\n\n2. What external libraries or dependencies does this code use?\n   - This code imports classes from the `org.alephium` and `org.alephium.util` packages, but it is unclear what external libraries or dependencies are required.\n\n3. What is the output of this code?\n   - This code prints two tables to the console: one showing the inflation rate based on hash rate, and another showing the inflation rate based on time. Each table includes three columns: the hash rate or year, the inflation rate as a decimal, and the yearly reward in ALPH."
    },
    {
      "fileName": "OpenApiUpdate.scala",
      "filePath": "tools/src/main/scala/org/alephium/tools/OpenApiUpdate.scala",
      "url": "https://github.com/alephium/alephium/tools/src/main/scala/org/alephium/tools/OpenApiUpdate.scala",
      "summary": "This code is responsible for generating and updating the OpenAPI documentation for the Alephium project. OpenAPI is a specification for building APIs that allows for easy documentation and client generation. The code imports several classes from the Alephium project, including `WalletDocumentation`, `GroupConfig`, and `Documentation`. \n\nThe `OpenApiUpdate` object is the main entry point for this code. It creates a new instance of `WalletDocumentation` and `Documentation`, which are used to generate the OpenAPI documentation. The `WalletDocumentation` class defines the endpoints for the wallet API, while the `Documentation` class defines the port number and other configuration options for the OpenAPI documentation. \n\nOnce the `Documentation` object is created, it generates the OpenAPI documentation using the `openApiJson` method from `OpenAPIWriters`. This method takes an instance of `OpenAPI` and a boolean flag indicating whether to drop authentication information from the documentation. The resulting JSON is then written to a file located at `../api/src/main/resources/openapi.json`.\n\nThis code is useful for developers who want to understand the API endpoints provided by the Alephium project. By generating OpenAPI documentation, developers can easily see what endpoints are available, what parameters they accept, and what responses they return. Additionally, the generated documentation can be used to automatically generate client code for the API in a variety of programming languages. \n\nExample usage:\n\n```scala\n// Generate OpenAPI documentation\nOpenApiUpdate.main(Array())\n```",
      "questions": "1. What is the purpose of this code?\n    \n    This code is responsible for updating the OpenAPI documentation for the Alephium project by generating a JSON file and writing it to a specific location.\n    \n2. What is the significance of the `GroupConfig` object being created and passed as an implicit parameter?\n    \n    The `GroupConfig` object is used to specify the number of groups in the Alephium network. It is passed as an implicit parameter to other objects that require this information, such as the `WalletDocumentation` and `Documentation` objects.\n    \n3. What is the purpose of the `maybeApiKey` field in the `Documentation` and `WalletDocumentation` objects?\n    \n    The `maybeApiKey` field is an optional API key that can be used to authenticate requests to the Alephium API. If it is not provided, certain endpoints may be restricted."
    },
    {
      "fileName": "ValidateDifficultyBombPatch.scala",
      "filePath": "tools/src/main/scala/org/alephium/tools/ValidateDifficultyBombPatch.scala",
      "url": "https://github.com/alephium/alephium/tools/src/main/scala/org/alephium/tools/ValidateDifficultyBombPatch.scala",
      "summary": "The `ValidateDifficultyBombPatch` object is a tool used to validate the difficulty bomb patch in the Alephium blockchain. The difficulty bomb is a mechanism that increases the difficulty of mining blocks over time, making it harder to mine new blocks. The purpose of the difficulty bomb patch is to prevent the difficulty from increasing too quickly, which could lead to a slowdown in block production.\n\nThe tool uses the Alephium blockchain's `BlockFlow` and `Storages` classes to retrieve information about the blockchain and calculate the expected hash rate. It then compares the expected hash rate to the actual hash rate and throws an exception if they do not match.\n\nThe tool takes the following steps to validate the difficulty bomb patch:\n\n1. It retrieves the root path of the Alephium project and loads the Alephium configuration.\n2. It creates a storage object for the mainnet database and a block flow object from the storage.\n3. It iterates over all the chain indexes in the configuration and retrieves the chain and public key.\n4. It creates a miner object from the public key and prepares a block flow template.\n5. It retrieves the parent block and calculates the height of the block at which the difficulty bomb patch was applied.\n6. It retrieves the target of the block at the calculated height and calculates the expected target.\n7. It calculates the expected hash rate and compares it to the actual hash rate.\n8. If the expected and actual hash rates do not match, it throws an exception. Otherwise, it prints a success message.\n\nThis tool is used to ensure that the difficulty bomb patch is working as intended and that the expected hash rate matches the actual hash rate. It is an important part of the Alephium project's quality assurance process.",
      "questions": "1. What is the purpose of this code?\n   \n   This code is a Scala script that validates the difficulty bomb patch for the Alephium blockchain by checking the expected and actual hash rates for each chain index.\n\n2. What dependencies does this code have?\n   \n   This code depends on several libraries and modules, including `java.nio.file.Path`, `org.alephium.flow.core.BlockFlow`, `org.alephium.flow.io.Storages`, `org.alephium.flow.setting.AlephiumConfig`, `org.alephium.io.RocksDBSource.Settings`, `org.alephium.protocol.ALPH`, `org.alephium.protocol.mining.HashRate`, `org.alephium.protocol.model.BlockDeps`, `org.alephium.protocol.model.Target`, `org.alephium.protocol.vm.LockupScript`, and `org.alephium.util.Env`.\n\n3. What is the expected output of this code?\n   \n   The expected output of this code is a list of hash rates for each chain index, along with a message indicating whether the validation succeeded or failed. If the expected and actual hash rates match, the script will print \"Succeeded\" followed by the hash rate. If they do not match, the script will throw a runtime exception with an error message."
    },
    {
      "fileName": "WalletGen.scala",
      "filePath": "tools/src/main/scala/org/alephium/tools/WalletGen.scala",
      "url": "https://github.com/alephium/alephium/tools/src/main/scala/org/alephium/tools/WalletGen.scala",
      "summary": "The `WalletGen` object is a tool for generating wallets for the Alephium cryptocurrency. It is used to generate a set of public and private keys, along with their corresponding addresses and mnemonics. \n\nThe `gen` method is the core of the tool. It takes a `GroupIndex` as input and returns a tuple containing an `Address`, a `SecP256K1PublicKey`, a `SecP256K1PrivateKey`, and a `Mnemonic`. The `GroupIndex` is used to ensure that the generated address belongs to the specified group. The method generates a random 24-word mnemonic, which is used to derive a BIP32 master key. From this master key, a private key, public key, and address are derived. If the generated address does not belong to the specified group, the method is called recursively until a valid address is generated.\n\nThe `WalletGen` object also contains a `main` method that generates wallets for two different network IDs. The `foreach` loop iterates over each network ID and generates wallets for a specified number of groups. The `printLine` method is used to print the results to the console.\n\nHere is an example of how to use the `WalletGen` tool:\n\n```scala\nimport org.alephium.tools.WalletGen\nimport org.alephium.protocol.config.GroupConfig\nimport org.alephium.protocol.model.GroupIndex\nimport org.alephium.protocol.model.NetworkId\n\nimplicit val config: GroupConfig = new GroupConfig {\n  override def groups: Int = 4\n}\n\nval (address, pubKey, priKey, mnemonic) = WalletGen.gen(GroupIndex.unsafe(0))\n\nprintln(s\"Address: ${address.toBase58}\")\nprintln(s\"Public Key: ${pubKey.toHexString}\")\nprintln(s\"Private Key: ${priKey.toHexString}\")\nprintln(s\"Mnemonic: ${mnemonic.toLongString}\")\n```\n\nThis code generates a wallet for the first group of the default network ID (1). The `GroupConfig` object specifies that there are 4 groups in the network. The `gen` method is called with a `GroupIndex` of 0 to generate a wallet for the first group. The resulting address, public key, private key, and mnemonic are printed to the console.",
      "questions": "1. What is the purpose of this code?\n   \n   This code generates wallet addresses, public and private keys, and mnemonics for the Alephium cryptocurrency project.\n\n2. What external libraries or dependencies does this code use?\n   \n   This code imports several libraries from the Alephium project, including `org.alephium.crypto`, `org.alephium.crypto.wallet`, `org.alephium.protocol`, and `org.alephium.wallet.Constants`.\n\n3. What is the output of this code?\n   \n   This code outputs wallet information for two different network IDs, including the group number, address, public key, private key, and mnemonic for each group."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/tools/src/main/scala/org/alephium/tools` folder contains various tools and utilities for the Alephium project. These tools help with tasks such as generating documentation, calculating inflation rates, validating patches, and generating wallets.\n\n`BuiltInFunctions.scala` is a tool that generates a JSON file containing information about the built-in functions in the Alephium protocol. This JSON file can be used by other tools to provide information about the functions to users, such as an IDE or a web-based documentation tool. Example usage:\n\n```scala\nimport org.alephium.tools.BuiltInFunctions\n\n// Generate JSON file containing built-in function information\nBuiltInFunctions.main(Array())\n```\n\n`DBV110ToV100.scala` is a Scala script that performs a database migration from version 1.1.0 to version 1.0.0 for the Alephium project. This script is intended to be run as a standalone application using the `sbt run` command and is used to ensure that the database schema is correctly migrated between versions.\n\n`MiningRewards.scala` is a tool that calculates the inflation rate of the Alephium cryptocurrency based on different parameters, such as the hashrate of the network and the number of years since the network's inception. This tool is useful for developers working on the Alephium project who need to calculate the inflation rate of the cryptocurrency based on different parameters.\n\n```scala\nimport org.alephium.tools.MiningRewards\n\n// Calculate inflation rate\nMiningRewards.main(Array())\n```\n\n`OpenApiUpdate.scala` generates and updates the OpenAPI documentation for the Alephium project. By generating OpenAPI documentation, developers can easily see what endpoints are available, what parameters they accept, and what responses they return. Example usage:\n\n```scala\n// Generate OpenAPI documentation\nOpenApiUpdate.main(Array())\n```\n\n`ValidateDifficultyBombPatch.scala` is a tool used to validate the difficulty bomb patch in the Alephium blockchain. This tool is used to ensure that the difficulty bomb patch is working as intended and that the expected hash rate matches the actual hash rate.\n\n`WalletGen.scala` is a tool for generating wallets for the Alephium cryptocurrency. It generates a set of public and private keys, along with their corresponding addresses and mnemonics. Example usage:\n\n```scala\nimport org.alephium.tools.WalletGen\nimport org.alephium.protocol.config.GroupConfig\nimport org.alephium.protocol.model.GroupIndex\n\nimplicit val config: GroupConfig = new GroupConfig {\n  override def groups: Int = 4\n}\n\nval (address, pubKey, priKey, mnemonic) = WalletGen.gen(GroupIndex.unsafe(0))\n\nprintln(s\"Address: ${address.toBase58}\")\nprintln(s\"Public Key: ${pubKey.toHexString}\")\nprintln(s\"Private Key: ${priKey.toHexString}\")\nprintln(s\"Mnemonic: ${mnemonic.toLongString}\")\n```\n\nThese tools are essential for various tasks in the Alephium project, such as generating documentation, calculating inflation rates, validating patches, and generating wallets. They help developers understand and work with the Alephium protocol more effectively.",
  "questions": ""
}