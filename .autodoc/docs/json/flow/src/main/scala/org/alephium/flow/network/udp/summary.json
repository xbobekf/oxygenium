{
  "folderName": "udp",
  "folderPath": ".autodoc/docs/json/flow/src/main/scala/org/alephium/flow/network/udp",
  "url": "https://github.com/alephium/alephium/.autodoc/docs/json/flow/src/main/scala/org/alephium/flow/network/udp",
  "files": [
    {
      "fileName": "SelectionHandler.scala",
      "filePath": "flow/src/main/scala/org/alephium/flow/network/udp/SelectionHandler.scala",
      "url": "https://github.com/alephium/alephium/flow/src/main/scala/org/alephium/flow/network/udp/SelectionHandler.scala",
      "summary": "The `SelectionHandler` object and class are part of the `alephium` project. The purpose of this code is to handle the selection of UDP packets from a selector. The `SelectionHandler` object is an extension of the Akka actor system, which is used to manage actors in the system. The `SelectionHandler` class is used to handle the selection of UDP packets from a selector.\n\nThe `SelectionHandler` object is created by extending the `ExtensionId` and `ExtensionIdProvider` traits. The `createExtension` method creates a new instance of the `SelectionHandler` class. The `selector` is created using the `Selector.open()` method. The `dispatcher` is created using the `system.dispatchers.lookup` method, which looks up the dispatcher with the name \"akka.io.pinned-dispatcher\". The `executionContext` is created using the `SerializedExecutionContext` class, which is a wrapper around the `ExecutionContext` that serializes the execution of tasks.\n\nThe `SelectionHandler` class is created with a `selector` and an `executionContext`. The `timeout` is set to 5 seconds. The `pendingTasks` is an `ArrayBuffer` that is used to store tasks that need to be executed. The `registerTask` method is used to add a task to the `pendingTasks` buffer and wake up the selector. The `select` method is used to select the UDP packets from the selector. The `pendingTasks` buffer is cleared and the selected keys are iterated over. If the key is valid, the UDP server is retrieved from the attachment and the ready operations are checked. If the ready operation is `SelectionKey.OP_READ`, then the UDP server is sent a `UdpServer.Read` message.\n\nThe `loop` method is used to execute the `select` method in a loop. The `select` method is executed in a try-catch block to handle exceptions. If the selector is open, the `select` method is executed again. If an exception is thrown, it is logged. The `loop` method is executed using the `executionContext`.\n\nOverall, the `SelectionHandler` object and class are used to handle the selection of UDP packets from a selector. The `SelectionHandler` object is an extension of the Akka actor system, which is used to manage actors in the system. The `SelectionHandler` class is used to handle the selection of UDP packets from a selector. The `registerTask` method is used to add a task to the `pendingTasks` buffer and wake up the selector. The `select` method is used to select the UDP packets from the selector. The `loop` method is used to execute the `select` method in a loop.",
      "questions": "1. What is the purpose of this code?\n   \n   This code is a modified version of akka.io.SelectionHandler and is used to handle selection of UDP channels.\n\n2. What external libraries or dependencies does this code use?\n   \n   This code uses the following external libraries or dependencies: \n   - akka.actor\n   - com.typesafe.scalalogging\n   - org.alephium.util.Duration\n   - java.nio.channels\n   \n3. What is the license for this code?\n   \n   This code is licensed under the GNU Lesser General Public License."
    },
    {
      "fileName": "SerializedExecutionContext.scala",
      "filePath": "flow/src/main/scala/org/alephium/flow/network/udp/SerializedExecutionContext.scala",
      "url": "https://github.com/alephium/alephium/flow/src/main/scala/org/alephium/flow/network/udp/SerializedExecutionContext.scala",
      "summary": "The code defines a SerializedExecutionContext class that extends the AbstractNodeQueue and implements the ExecutionContext trait. The purpose of this class is to provide a serialized execution context for tasks that need to be executed in a specific order. \n\nThe SerializedExecutionContext is created by calling the apply method of the companion object, which takes an ExecutionContext as a parameter. The resulting SerializedExecutionContext can then be used to execute tasks in a serialized manner. \n\nThe SerializedExecutionContext works by maintaining a queue of tasks that need to be executed. When a task is added to the queue, the attach method is called to ensure that the task is executed as soon as possible. The attach method checks if the queue is empty and if the execution context is currently on. If the queue is not empty and the execution context is not currently on, the context is turned on and the run method is called. \n\nThe run method is responsible for executing the tasks in the queue. It does this by polling the queue for the next task to execute. If the queue is empty, the turnOff method is called to turn off the execution context. If there is a task in the queue, it is executed and the run method is called again to execute the next task. \n\nIf an exception is thrown while executing a task, the reportFailure method of the underlying execution context is called to report the failure. \n\nOverall, the SerializedExecutionContext provides a way to execute tasks in a serialized manner, ensuring that they are executed in the order they are added to the queue. This can be useful in situations where tasks need to be executed in a specific order, such as when processing network messages. \n\nExample usage:\n\n```scala\nimport org.alephium.flow.network.udp.SerializedExecutionContext\n\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\n\nval serializedContext = SerializedExecutionContext(global)\n\nval task1 = Future {\n  // do some work\n}\n\nval task2 = Future {\n  // do some other work\n}\n\nserializedContext.execute(() => task1)\nserializedContext.execute(() => task2)\n``` \n\nIn this example, two tasks are created using the Future construct. The tasks are then added to the SerializedExecutionContext using the execute method. Because the SerializedExecutionContext is used, the tasks will be executed in the order they were added to the queue, ensuring that task1 is executed before task2.",
      "questions": "1. What is the purpose of the `SerializedExecutionContext` class?\n- The `SerializedExecutionContext` class is a modified version of `akk.io.SerializedSuspendableExecutionContext` that provides a serialized execution context for running tasks in a single thread.\n\n2. What is the significance of the `GNU Lesser General Public License` mentioned in the code?\n- The `GNU Lesser General Public License` is the license under which the `alephium` project is distributed, and it allows for the free distribution and modification of the library.\n\n3. What is the relationship between the `SerializedExecutionContext` class and the `AbstractNodeQueue` trait?\n- The `SerializedExecutionContext` class extends the `AbstractNodeQueue` trait, which provides a thread-safe implementation of a linked list that can be used to store and execute tasks in a serialized manner."
    },
    {
      "fileName": "UdpServer.scala",
      "filePath": "flow/src/main/scala/org/alephium/flow/network/udp/UdpServer.scala",
      "url": "https://github.com/alephium/alephium/flow/src/main/scala/org/alephium/flow/network/udp/UdpServer.scala",
      "summary": "The `UdpServer` class is a Scala implementation of a UDP server that can be used to send and receive data over a network. It is part of the Alephium project and is licensed under the GNU Lesser General Public License.\n\nThe class defines a number of commands and events that can be used to interact with the server. The `Bind` command is used to bind the server to a specific network address, while the `Send` command is used to send data to a remote address. The `Read` command is used internally to read data from the network.\n\nThe `UdpServer` class uses a non-blocking I/O model to handle incoming and outgoing data. When the server is started, it creates a `DatagramChannel` and registers it with a `SelectionHandler`. The `SelectionHandler` is responsible for monitoring the channel for incoming data and notifying the server when data is available to be read.\n\nWhen data is received, the server reads it into a buffer and sends it to the `discoveryServer` actor, which is responsible for handling the data. The `discoveryServer` actor can then process the data as needed.\n\nThe `UdpServer` class also includes error handling code to handle failures that may occur during operation. If an error occurs, the server logs a warning message and attempts to recover. If the error is fatal, the server stops itself.\n\nOverall, the `UdpServer` class provides a simple and efficient way to send and receive data over a network using UDP. It can be used as part of a larger network application to handle incoming and outgoing data.",
      "questions": "1. What is the purpose of this code?\n- This code is a part of the `alephium` project and it implements a UDP server that can bind to a specific address and send/receive data over UDP.\n\n2. What is the license for this code?\n- This code is licensed under the GNU Lesser General Public License version 3 or later.\n\n3. How does this code handle UDP packet reception?\n- The `listening` method is responsible for receiving UDP packets. It uses a `ByteBuffer` to read data from the channel and sends the received data to the `discoveryServer` actor. It uses tail recursion to read multiple packets if available, and registers a task with the `sharedSelectionHandler` to resume reading when the channel is ready for more data."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/flow/src/main/scala/org/alephium/flow/network/udp` folder contains code for handling UDP communication in the Alephium project. It includes three main files: `SelectionHandler.scala`, `SerializedExecutionContext.scala`, and `UdpServer.scala`.\n\n`SelectionHandler.scala` defines the `SelectionHandler` object and class, which are responsible for selecting UDP packets from a selector. The object extends the Akka actor system, while the class handles the actual packet selection. The `registerTask` method adds tasks to the `pendingTasks` buffer and wakes up the selector. The `select` method selects UDP packets from the selector, and the `loop` method executes the `select` method in a loop.\n\n```scala\nval selectionHandler = SelectionHandler(system)\nval udpServer = new UdpServer(selectionHandler)\nselectionHandler.registerTask(udpServer)\n```\n\n`SerializedExecutionContext.scala` provides the `SerializedExecutionContext` class, which is a serialized execution context for tasks that need to be executed in a specific order. It maintains a queue of tasks and ensures they are executed in the order they are added. This is useful when processing network messages that need to be executed in a specific order.\n\n```scala\nimport org.alephium.flow.network.udp.SerializedExecutionContext\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.Future\n\nval serializedContext = SerializedExecutionContext(global)\nval task1 = Future { /* do some work */ }\nval task2 = Future { /* do some other work */ }\n\nserializedContext.execute(() => task1)\nserializedContext.execute(() => task2)\n```\n\n`UdpServer.scala` implements a UDP server for sending and receiving data over a network. It defines commands and events for interacting with the server, such as `Bind`, `Send`, and `Read`. The server uses a non-blocking I/O model, creating a `DatagramChannel` and registering it with a `SelectionHandler`. The `SelectionHandler` monitors the channel for incoming data and notifies the server when data is available to be read. The server then sends the data to the `discoveryServer` actor for processing.\n\n```scala\nval udpServer = new UdpServer(selectionHandler)\nudpServer ! UdpServer.Bind(localAddress)\nudpServer ! UdpServer.Send(data, remoteAddress)\n```\n\nIn summary, this folder contains code for handling UDP communication in the Alephium project. The `SelectionHandler` class selects UDP packets from a selector, the `SerializedExecutionContext` class provides a serialized execution context for tasks, and the `UdpServer` class implements a UDP server for sending and receiving data over a network. These components work together to enable efficient network communication in the Alephium project.",
  "questions": ""
}