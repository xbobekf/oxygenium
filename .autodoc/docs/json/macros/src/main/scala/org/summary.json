{
  "folderName": "org",
  "folderPath": ".autodoc/docs/json/macros/src/main/scala/org",
  "url": "https://github.com/alephium/alephium/.autodoc/docs/json/macros/src/main/scala/org",
  "files": [],
  "folders": [
    {
      "folderName": "alephium",
      "folderPath": ".autodoc/docs/json/macros/src/main/scala/org/alephium",
      "url": "https://github.com/alephium/alephium/.autodoc/docs/json/macros/src/main/scala/org/alephium",
      "files": [],
      "folders": [
        {
          "folderName": "macros",
          "folderPath": ".autodoc/docs/json/macros/src/main/scala/org/alephium/macros",
          "url": "https://github.com/alephium/alephium/.autodoc/docs/json/macros/src/main/scala/org/alephium/macros",
          "files": [
            {
              "fileName": "ByteCode.scala",
              "filePath": "macros/src/main/scala/org/alephium/macros/ByteCode.scala",
              "url": "https://github.com/alephium/alephium/macros/src/main/scala/org/alephium/macros/ByteCode.scala",
              "summary": "The code defines a Scala macro annotation called `ByteCode`. This annotation can be used to add a `code` method to case classes that return a `Byte` value. The `code` method is added to the case class and returns the `Byte` value of the companion object of the case class. \n\nThe `ByteCode` annotation is defined as a Scala macro annotation using the `scala.annotation.StaticAnnotation` trait. The `macroTransform` method is used to transform the annotated code. The `ByteCodeImpl` object contains the implementation of the macro. \n\nThe `ByteCodeImpl` object defines a `impl` method that takes a `whitebox.Context` and a list of `annottees` as parameters. The `annottees` parameter is a list of trees that represent the annotated code. The `impl` method pattern matches on the `annottees` parameter to extract the class definition and the companion object definition. \n\nIf the `annottees` parameter contains a class definition and a companion object definition, the `addByteCode` method is called with the class definition and the companion object definition as parameters. The `addByteCode` method pattern matches on the class definition and the companion object definition to extract the class name, fields, parents, and body of the class definition and the base, and body of the companion object definition. \n\nIf the class definition is a final case class, the `addByteCode` method returns a new tree that adds a `code` method to the class definition. The `code` method returns the `Byte` value of the companion object of the case class. The `addByteCode` method also returns a new tree that contains the original companion object definition. \n\nIf the `annottees` parameter does not contain a class definition and a companion object definition, the `impl` method calls the `abort` method to abort the macro expansion. \n\nThe `ByteCode` annotation can be used to add a `code` method to case classes that return a `Byte` value. For example, the following code defines a case class called `MyClass` and adds the `ByteCode` annotation to it:\n\n```scala\n@ByteCode\nfinal case class MyClass(a: Int, b: String)\nobject MyClass {\n  val code: Byte = 0x01\n}\n```\n\nAfter the macro expansion, the `MyClass` case class will have a `code` method that returns the `Byte` value `0x01`. The `code` method can be called on an instance of the `MyClass` case class to get its `Byte` code value.",
              "questions": "1. What is the purpose of this code file?\n- This code file is a Scala macro that adds a `code` method to case classes annotated with `@ByteCode`.\n\n2. What is the license for this code?\n- This code is licensed under the GNU Lesser General Public License version 3 or later.\n\n3. What is the expected input and output of the `macroTransform` method?\n- The `macroTransform` method takes in a variable number of `annottees` and returns an expression that represents the transformed code. The `annottees` are expected to be a case class and a companion object."
            },
            {
              "fileName": "EnumerationMacros.scala",
              "filePath": "macros/src/main/scala/org/alephium/macros/EnumerationMacros.scala",
              "url": "https://github.com/alephium/alephium/macros/src/main/scala/org/alephium/macros/EnumerationMacros.scala",
              "summary": "The code defines a Scala object called `EnumerationMacros` that contains a single method called `sealedInstancesOf`. This method takes a type parameter `A` and returns a `TreeSet` of instances of the sealed trait or class `A`. The method uses Scala macros to generate the set of instances at compile time.\n\nThe `sealedInstancesOf` method first checks that the type `A` is a sealed trait or class. If it is not, the method throws an exception. If `A` is a sealed trait or class, the method retrieves all of its direct subclasses using the `knownDirectSubclasses` method. It then checks that all of the subclasses are objects (i.e., singleton instances of their respective classes) and throws an exception if any of them are not.\n\nFinally, the method constructs a `TreeSet` of the objects by calling the `apply` method of the `TreeSet` companion object and passing in a list of `Ident` nodes that reference the singleton objects. The `Ident` nodes are constructed using the `sourceModuleRef` method, which takes a `Symbol` representing a class or object and returns an `Ident` node that references the singleton instance of the object.\n\nThis code can be used in the larger project to generate sets of instances of sealed traits or classes. For example, suppose we have a sealed trait called `Fruit` with two case classes `Apple` and `Orange` that extend it:\n\n```\nsealed trait Fruit\ncase class Apple() extends Fruit\ncase class Orange() extends Fruit\n```\n\nWe can use the `sealedInstancesOf` method to generate a `TreeSet` of all instances of `Fruit` as follows:\n\n```\nval fruits = EnumerationMacros.sealedInstancesOf[Fruit]\n```\n\nThis will generate a `TreeSet` containing the singleton instances of `Apple` and `Orange`. We can then use this set to perform operations on all instances of `Fruit`, such as iterating over them or filtering them based on some criteria.",
              "questions": "1. What is the purpose of this code?\n   - This code defines a macro for enumerating all instances of a sealed trait or class in Scala.\n\n2. What is the license for this code?\n   - This code is licensed under the GNU Lesser General Public License, version 3 or later.\n\n3. What are the requirements for using this macro?\n   - This macro can only be used with a sealed trait or class, and all of its children must be objects."
            },
            {
              "fileName": "Gas.scala",
              "filePath": "macros/src/main/scala/org/alephium/macros/Gas.scala",
              "url": "https://github.com/alephium/alephium/macros/src/main/scala/org/alephium/macros/Gas.scala",
              "summary": "The code defines a Scala macro annotation called `Gas`. This annotation is used to add a `gas()` method to a trait and its companion object. The `gas()` method returns a `GasBox` object. \n\nThe `Gas` annotation is defined as a `StaticAnnotation` and is marked with `@compileTimeOnly` to indicate that it can only be used at compile-time. The `macroTransform` method is used to transform the annotated code. It takes a variable number of `annottees` as input, which are the elements that are annotated with `Gas`. \n\nThe `GasImpl` object defines the implementation of the `Gas` annotation. It defines a `impl` method that takes a `whitebox.Context` object and a variable number of `annottees` as input. The `whitebox.Context` object is used to access the Scala compiler's internal representation of the code. \n\nThe `impl` method first checks that the `annottees` list contains a `ClassDef` and a `ModuleDef`. If it does, it calls the `addByteCode` method to add the `gas()` method to the `ClassDef` and the `ModuleDef`. If the `annottees` list does not contain a `ClassDef` and a `ModuleDef`, the `impl` method aborts with an error message.\n\nThe `addByteCode` method takes a `ClassDef` and a `ModuleDef` as input. It checks that the `ClassDef` is a trait and the `ModuleDef` is an object. If they are, it adds a `gas()` method to the trait that returns the `gas` field of the companion object. It then returns the modified `ClassDef` and `ModuleDef` as a new `Expr[Any]` object. If the `ClassDef` and `ModuleDef` are not in the expected format, the `addByteCode` method aborts with an error message.\n\nOverall, the `Gas` annotation is used to add a `gas()` method to a trait and its companion object. This method returns a `GasBox` object. The `GasImpl` object defines the implementation of the `Gas` annotation, which uses the `whitebox.Context` object to modify the code at compile-time.",
              "questions": "1. What is the purpose of the `Gas` annotation and how is it used?\n   - The `Gas` annotation is a macro annotation that is used to add a `gas()` method to a trait. It is used to generate bytecode for the `gas()` method at compile-time.\n2. What is the expected input format for the `Gas` annotation?\n   - The `Gas` annotation is expected to be applied to a trait and an object that defines a `gas` method. The trait is used to add the `gas()` method to its interface, while the object is used to provide the implementation for the `gas()` method.\n3. What happens if the input format for the `Gas` annotation is invalid?\n   - If the input format for the `Gas` annotation is invalid, the `impl` method will call the `abort()` method and raise an error with a message indicating that the annottee is invalid."
            },
            {
              "fileName": "HPC.scala",
              "filePath": "macros/src/main/scala/org/alephium/macros/HPC.scala",
              "url": "https://github.com/alephium/alephium/macros/src/main/scala/org/alephium/macros/HPC.scala",
              "summary": "The `HPC` object in this file contains a single method `cfor` that is used to create a C-style for loop in Scala. This method takes three parameters: `init`, `test`, and `next`, which are the initial value, the test condition, and the next value of the loop variable, respectively. The `body` parameter is a function that takes the loop variable as input and performs the loop body. The `cfor` method uses Scala macros to generate efficient code for the loop.\n\nThe `cforMacro` method is the macro implementation of the `cfor` method. It takes four parameters: `c`, `init`, `test`, `next`, and `body`. The `c` parameter is the macro context, which is used to generate the macro expansion. The other parameters are the same as those of the `cfor` method. The `cforMacro` method generates a while loop that performs the same function as the C-style for loop. The loop variable is initialized to the `init` value, and the loop continues as long as the `test` condition is true. The `body` function is called with the loop variable as input, and the loop variable is updated to the `next` value at the end of each iteration.\n\nThe `SyntaxUtil` class provides utility methods for generating fresh names for variables and checking whether expressions are \"clean\" (i.e., they consist only of identifiers and function literals). The `InlineUtil` class provides a method for inlining function applications in the macro expansion. These classes are used internally by the `cforMacro` method.\n\nOverall, this file provides a useful utility method for creating C-style for loops in Scala. This method can be used in any project that requires efficient looping over a range of values. An example usage of the `cfor` method is shown below:\n\n```scala\nimport org.alephium.macros.HPC._\n\ncfor(0)(_ < 10, _ + 1) { i =>\n  println(i)\n}\n```\n\nThis code will print the numbers from 0 to 9.",
              "questions": "1. What is the purpose of the `cfor` method?\n    \n    The `cfor` method is a macro that provides a C-style for loop. It takes an initial value, a test function, a next function, and a body function, and executes the body function repeatedly while the test function returns true, updating the value with the next function each time.\n\n2. What is the purpose of the `HPC` object?\n    \n    The `HPC` object provides the `cfor` method, which is a macro that provides a C-style for loop.\n\n3. What is the purpose of the `SyntaxUtil` and `InlineUtil` classes?\n    \n    The `SyntaxUtil` class provides utility methods for working with Scala syntax, such as generating fresh term names and checking whether expressions are \"clean\". The `InlineUtil` class provides a method for inlining function applications in a tree, which is used by the `cfor` macro."
            },
            {
              "fileName": "HashSerde.scala",
              "filePath": "macros/src/main/scala/org/alephium/macros/HashSerde.scala",
              "url": "https://github.com/alephium/alephium/macros/src/main/scala/org/alephium/macros/HashSerde.scala",
              "summary": "The code defines a Scala macro annotation called `HashSerde`. This annotation is used to generate boilerplate code for classes that need to be serialized and hashed. The generated code adds a `bytes` field to the class that contains the serialized representation of the object, a `hash` field that contains the hash of the serialized bytes, and a `shortHex` method that returns a short hexadecimal string representation of the hash.\n\nThe `HashSerde` annotation is applied to a case class and an object that contains the companion object of the case class. The generated code adds the `bytes`, `hash`, and `shortHex` fields and methods to the case class and the companion object.\n\nThe `HashSerde` annotation is implemented using Scala macros. The `impl` method of the `HashSerdeImpl` object is the macro implementation. The macro takes the annotated class and object as input and generates the code that adds the `bytes`, `hash`, and `shortHex` fields and methods.\n\nThe `HashSerde` annotation is useful in the Alephium project because it simplifies the process of serializing and hashing objects. By using the annotation, developers can avoid writing boilerplate code for each class that needs to be serialized and hashed. Instead, they can simply annotate the class with `HashSerde` and the necessary code will be generated automatically.\n\nExample usage:\n\n```scala\nimport org.alephium.macros.HashSerde\n\n@HashSerde\ncase class Person(name: String, age: Int)\n\nval person = Person(\"Alice\", 30)\nval bytes = person.bytes\nval hash = person.hash\nval shortHex = person.shortHex\n```",
              "questions": "1. What is the purpose of the `HashSerde` annotation and how is it used?\n   - The `HashSerde` annotation is a macro annotation that generates additional code for a case class and its companion object. It is used to add serialization and hashing functionality to the annotated class.\n   \n2. What is the expected input format for the `macroTransform` method?\n   - The `macroTransform` method expects one or more `Expr` arguments, which represent the annotated code elements that the macro will transform.\n\n3. What is the purpose of the `addHash` method and how does it work?\n   - The `addHash` method takes in a `ClassDef` and a `ModuleDef` and returns an `Expr` that represents the modified code. It works by pattern matching the input code elements to ensure they are in the expected format, and then generating additional code that adds serialization, hashing, and other functionality to the case class and its companion object."
            }
          ],
          "folders": [],
          "summary": "The `.autodoc/docs/json/macros/src/main/scala/org/alephium/macros` folder contains Scala macros and annotations that help generate boilerplate code and improve code efficiency in the Alephium project. These macros and annotations are used to automatically generate code for serialization, hashing, enumeration of sealed traits, and C-style for loops.\n\n1. **ByteCode.scala**: This file defines a `ByteCode` macro annotation that adds a `code` method to case classes, returning a `Byte` value from the companion object. This can be useful when you need to associate a unique byte code with each case class instance.\n\n   Example usage:\n   ```scala\n   @ByteCode\n   final case class MyClass(a: Int, b: String)\n   object MyClass {\n     val code: Byte = 0x01\n   }\n   ```\n\n2. **EnumerationMacros.scala**: This file defines a `sealedInstancesOf` method that generates a `TreeSet` of instances of a sealed trait or class at compile time. This can be useful when you need to perform operations on all instances of a sealed trait or class.\n\n   Example usage:\n   ```scala\n   sealed trait Fruit\n   case class Apple() extends Fruit\n   case class Orange() extends Fruit\n\n   val fruits = EnumerationMacros.sealedInstancesOf[Fruit]\n   ```\n\n3. **Gas.scala**: This file defines a `Gas` macro annotation that adds a `gas()` method to a trait and its companion object, returning a `GasBox` object. This can be useful when you need to associate a gas cost with certain operations in the Alephium project.\n\n   Example usage:\n   ```scala\n   @Gas\n   trait MyTrait\n   object MyTrait {\n     val gas: GasBox = GasBox(100)\n   }\n   ```\n\n4. **HPC.scala**: This file defines a `cfor` method that creates a C-style for loop in Scala, improving loop efficiency. This can be useful when you need to perform efficient looping over a range of values.\n\n   Example usage:\n   ```scala\n   import org.alephium.macros.HPC._\n\n   cfor(0)(_ < 10, _ + 1) { i =>\n     println(i)\n   }\n   ```\n\n5. **HashSerde.scala**: This file defines a `HashSerde` macro annotation that generates boilerplate code for classes that need to be serialized and hashed. The generated code adds a `bytes` field, a `hash` field, and a `shortHex` method to the annotated class and its companion object.\n\n   Example usage:\n   ```scala\n   import org.alephium.macros.HashSerde\n\n   @HashSerde\n   case class Person(name: String, age: Int)\n\n   val person = Person(\"Alice\", 30)\n   val bytes = person.bytes\n   val hash = person.hash\n   val shortHex = person.shortHex\n   ```\n\nThese macros and annotations help reduce boilerplate code, improve code efficiency, and simplify the development process in the Alephium project. They can be used in various parts of the project where serialization, hashing, enumeration, and efficient looping are required.",
          "questions": ""
        }
      ],
      "summary": "The `.autodoc/docs/json/macros/src/main/scala/org/alephium/macros` folder contains Scala macros and annotations that help generate boilerplate code and improve code efficiency in the Alephium project. These macros and annotations are used to automatically generate code for serialization, hashing, enumeration of sealed traits, and C-style for loops.\n\n1. **ByteCode.scala**: This file defines a `ByteCode` macro annotation that adds a `code` method to case classes, returning a `Byte` value from the companion object. This can be useful when you need to associate a unique byte code with each case class instance.\n\n   Example usage:\n   ```scala\n   @ByteCode\n   final case class MyClass(a: Int, b: String)\n   object MyClass {\n     val code: Byte = 0x01\n   }\n   ```\n\n2. **EnumerationMacros.scala**: This file defines a `sealedInstancesOf` method that generates a `TreeSet` of instances of a sealed trait or class at compile time. This can be useful when you need to perform operations on all instances of a sealed trait or class.\n\n   Example usage:\n   ```scala\n   sealed trait Fruit\n   case class Apple() extends Fruit\n   case class Orange() extends Fruit\n\n   val fruits = EnumerationMacros.sealedInstancesOf[Fruit]\n   ```\n\n3. **Gas.scala**: This file defines a `Gas` macro annotation that adds a `gas()` method to a trait and its companion object, returning a `GasBox` object. This can be useful when you need to associate a gas cost with certain operations in the Alephium project.\n\n   Example usage:\n   ```scala\n   @Gas\n   trait MyTrait\n   object MyTrait {\n     val gas: GasBox = GasBox(100)\n   }\n   ```\n\n4. **HPC.scala**: This file defines a `cfor` method that creates a C-style for loop in Scala, improving loop efficiency. This can be useful when you need to perform efficient looping over a range of values.\n\n   Example usage:\n   ```scala\n   import org.alephium.macros.HPC._\n\n   cfor(0)(_ < 10, _ + 1) { i =>\n     println(i)\n   }\n   ```\n\n5. **HashSerde.scala**: This file defines a `HashSerde` macro annotation that generates boilerplate code for classes that need to be serialized and hashed. The generated code adds a `bytes` field, a `hash` field, and a `shortHex` method to the annotated class and its companion object.\n\n   Example usage:\n   ```scala\n   import org.alephium.macros.HashSerde\n\n   @HashSerde\n   case class Person(name: String, age: Int)\n\n   val person = Person(\"Alice\", 30)\n   val bytes = person.bytes\n   val hash = person.hash\n   val shortHex = person.shortHex\n   ```\n\nThese macros and annotations help reduce boilerplate code, improve code efficiency, and simplify the development process in the Alephium project. They can be used in various parts of the project where serialization, hashing, enumeration, and efficient looping are required.",
      "questions": ""
    }
  ],
  "summary": "The `.autodoc/docs/json/macros/src/main/scala/org/alephium/macros` folder contains Scala macros and annotations that help generate boilerplate code and improve code efficiency in the Alephium project. These macros and annotations are used to automatically generate code for serialization, hashing, enumeration of sealed traits, and C-style for loops.\n\n1. **ByteCode.scala**: This file defines a `ByteCode` macro annotation that adds a `code` method to case classes, returning a `Byte` value from the companion object. This can be useful when you need to associate a unique byte code with each case class instance.\n\n   Example usage:\n   ```scala\n   @ByteCode\n   final case class MyClass(a: Int, b: String)\n   object MyClass {\n     val code: Byte = 0x01\n   }\n   ```\n\n2. **EnumerationMacros.scala**: This file defines a `sealedInstancesOf` method that generates a `TreeSet` of instances of a sealed trait or class at compile time. This can be useful when you need to perform operations on all instances of a sealed trait or class.\n\n   Example usage:\n   ```scala\n   sealed trait Fruit\n   case class Apple() extends Fruit\n   case class Orange() extends Fruit\n\n   val fruits = EnumerationMacros.sealedInstancesOf[Fruit]\n   ```\n\n3. **Gas.scala**: This file defines a `Gas` macro annotation that adds a `gas()` method to a trait and its companion object, returning a `GasBox` object. This can be useful when you need to associate a gas cost with certain operations in the Alephium project.\n\n   Example usage:\n   ```scala\n   @Gas\n   trait MyTrait\n   object MyTrait {\n     val gas: GasBox = GasBox(100)\n   }\n   ```\n\n4. **HPC.scala**: This file defines a `cfor` method that creates a C-style for loop in Scala, improving loop efficiency. This can be useful when you need to perform efficient looping over a range of values.\n\n   Example usage:\n   ```scala\n   import org.alephium.macros.HPC._\n\n   cfor(0)(_ < 10, _ + 1) { i =>\n     println(i)\n   }\n   ```\n\n5. **HashSerde.scala**: This file defines a `HashSerde` macro annotation that generates boilerplate code for classes that need to be serialized and hashed. The generated code adds a `bytes` field, a `hash` field, and a `shortHex` method to the annotated class and its companion object.\n\n   Example usage:\n   ```scala\n   import org.alephium.macros.HashSerde\n\n   @HashSerde\n   case class Person(name: String, age: Int)\n\n   val person = Person(\"Alice\", 30)\n   val bytes = person.bytes\n   val hash = person.hash\n   val shortHex = person.shortHex\n   ```\n\nThese macros and annotations help reduce boilerplate code, improve code efficiency, and simplify the development process in the Alephium project. They can be used in various parts of the project where serialization, hashing, enumeration, and efficient looping are required.",
  "questions": ""
}