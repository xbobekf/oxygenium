{
  "folderName": "wallet",
  "folderPath": ".autodoc/docs/json/crypto/src/main/scala/org/alephium/crypto/wallet",
  "url": "https://github.com/alephium/alephium/.autodoc/docs/json/crypto/src/main/scala/org/alephium/crypto/wallet",
  "files": [
    {
      "fileName": "BIP32.scala",
      "filePath": "crypto/src/main/scala/org/alephium/crypto/wallet/BIP32.scala",
      "url": "https://github.com/alephium/alephium/crypto/src/main/scala/org/alephium/crypto/wallet/BIP32.scala",
      "summary": "The `BIP32` object in the `org.alephium.crypto.wallet` package provides functionality for generating and manipulating hierarchical deterministic (HD) wallets using the BIP32 standard. HD wallets allow for the generation of a large number of public/private key pairs from a single seed, which can be used to derive child keys in a deterministic manner. This is useful for applications such as cryptocurrency wallets, where a user may want to generate a new address for each transaction.\n\nThe `BIP32` object provides several methods for generating master keys from a seed, including `masterKey`, `btcMasterKey`, and `alphMasterKey`. These methods take a `ByteString` seed as input and return an `ExtendedPrivateKey` object, which represents the root of the HD wallet. The `masterKey` method takes an additional `prefix` argument, which is used to generate a unique master key for different applications. For example, the `btcMasterKey` method generates a master key for use with Bitcoin wallets, while the `alphMasterKey` method generates a master key for use with Alephium wallets.\n\nThe `BIP32` object also provides methods for deriving child keys from a parent key, including `derive` and `derivePath`. The `derive` method takes an integer index as input and returns an `Option[ExtendedPrivateKey]` or `Option[ExtendedPublicKey]` object, depending on whether the parent key is a private or public key. If the index is a \"hardened\" index (i.e., less than 0), the method returns a private key; otherwise, it returns a public key. The `derivePath` method takes a vector of integers as input and recursively derives child keys from the parent key. Both methods return `None` if the derived key is invalid (i.e., has a private key with value greater than the curve order).\n\nThe `BIP32` object also provides several utility methods, including `isHardened`, `harden`, `unharden`, `hmacSha512`, and `showDerivationPath`. The `isHardened` method takes an integer index as input and returns `true` if the index is a hardened index. The `harden` method takes an integer index as input and returns the corresponding hardened index. The `unharden` method takes a hardened index as input and returns the corresponding non-hardened index. The `hmacSha512` method takes two `ByteString` objects as input and returns the HMAC-SHA512 hash of the data using the key. The `showDerivationPath` method takes a vector of integers as input and returns a string representation of the derivation path.\n\nOverall, the `BIP32` object provides a convenient and secure way to generate and manipulate HD wallets using the BIP32 standard. It can be used in conjunction with other cryptocurrency libraries to implement wallet functionality in a larger project. For example, it could be used to generate a new address for each transaction in a cryptocurrency wallet application.",
      "questions": "1. What is the purpose of the `BIP32` object?\n- The `BIP32` object provides functionality for generating and manipulating extended private and public keys for hierarchical deterministic wallets.\n\n2. What is the significance of the `isHardened`, `harden`, and `unharden` functions?\n- These functions are used to determine whether an index is hardened (i.e. greater than or equal to 2^31) and to convert between hardened and non-hardened indices.\n\n3. What is the difference between `ExtendedPrivateKey` and `ExtendedPublicKey`?\n- `ExtendedPrivateKey` represents an extended private key, which can be used to derive child private keys and extended public keys. `ExtendedPublicKey` represents an extended public key, which can be used to derive child public keys."
    },
    {
      "fileName": "Mnemonic.scala",
      "filePath": "crypto/src/main/scala/org/alephium/crypto/wallet/Mnemonic.scala",
      "url": "https://github.com/alephium/alephium/crypto/src/main/scala/org/alephium/crypto/wallet/Mnemonic.scala",
      "summary": "The `Mnemonic` object and its accompanying `Mnemonic` case class provide functionality for generating and validating mnemonic phrases, which are used to generate cryptographic keys for wallets. \n\nThe `Mnemonic` case class represents a mnemonic phrase as a vector of words. It provides methods for converting the phrase to a seed, which can be used to generate cryptographic keys. The `toSeed` method takes an optional passphrase and returns a `ByteString` representing the seed. The seed is generated using the PBKDF2 key derivation function with HMAC-SHA512 as the pseudorandom function. The mnemonic phrase and an extended passphrase (which is the string \"mnemonic\" concatenated with the passphrase, if provided) are used as the password and salt, respectively. The number of iterations and the length of the derived key are specified by the constants `pbkdf2Iterations` and `pbkdf2KeyLength`, respectively.\n\nThe `Mnemonic` object provides methods for generating and validating mnemonic phrases. The `generate` method takes a size (in words) and returns an `Option[Mnemonic]` representing a randomly generated mnemonic phrase of the specified size. The size must be one of the values in the `Size` case class, which provides a list of valid sizes. The `from` method takes a string and returns an `Option[Mnemonic]` representing the mnemonic phrase if the string is a valid sequence of words from the English wordlist. The `unsafe` methods are similar to the `from` methods, but they assume that the input is valid and do not return an `Option`. The `fromEntropyUnsafe` method takes a `ByteString` representing the entropy used to generate the mnemonic phrase and returns a `Mnemonic`. The `unsafe` method takes a `ByteString` representing the entropy and returns a `Mnemonic`. \n\nThe `Mnemonic` object also provides a list of valid entropy sizes (`entropySizes`), the PBKDF2 algorithm (`pbkdf2Algorithm`), the number of iterations (`pbkdf2Iterations`), the length of the derived key (`pbkdf2KeyLength`), and the English wordlist (`englishWordlist`). The `validateWords` method is used to validate a sequence of words, and the `validateEntropy` method is used to validate a `ByteString` representing entropy. \n\nOverall, the `Mnemonic` object and case class provide a convenient and secure way to generate and validate mnemonic phrases, which are an important component of wallet security. \n\nExample usage:\n\n```scala\nval mnemonicOpt = Mnemonic.generate(24)\nmnemonicOpt.foreach { mnemonic =>\n  val seed = mnemonic.toSeed(Some(\"passphrase\"))\n  // use seed to generate cryptographic keys\n}\n```",
      "questions": "1. What is the purpose of the `Mnemonic` class and how is it used?\n- The `Mnemonic` class represents a list of words used to generate a seed for a cryptocurrency wallet. It can be converted to a seed using the `toSeed` method.\n2. What is the significance of the `pbkdf2Algorithm`, `pbkdf2Iterations`, and `pbkdf2KeyLength` constants?\n- These constants are used to specify the algorithm, number of iterations, and key length for the PBKDF2 key derivation function used to generate the seed from the mnemonic and passphrase.\n3. What is the purpose of the `validateWords` method and when is it called?\n- The `validateWords` method is used to check if an array of words is a valid mnemonic of a certain size and contains only words from the English wordlist. It is called by the `from` method to create a `Mnemonic` instance from a string of space-separated words."
    }
  ],
  "folders": [],
  "summary": "The `org.alephium.crypto.wallet` package provides functionality for generating and manipulating hierarchical deterministic (HD) wallets using the BIP32 standard and mnemonic phrases. HD wallets allow for the generation of a large number of public/private key pairs from a single seed, which can be used to derive child keys in a deterministic manner. This is useful for applications such as cryptocurrency wallets, where a user may want to generate a new address for each transaction.\n\nThe `BIP32` object provides several methods for generating master keys from a seed, such as `masterKey`, `btcMasterKey`, and `alphMasterKey`. These methods take a `ByteString` seed as input and return an `ExtendedPrivateKey` object, which represents the root of the HD wallet. The `masterKey` method takes an additional `prefix` argument, which is used to generate a unique master key for different applications.\n\n```scala\nval seed: ByteString = ...\nval masterKey = BIP32.alphMasterKey(seed)\n```\n\nThe `BIP32` object also provides methods for deriving child keys from a parent key, including `derive` and `derivePath`. The `derive` method takes an integer index as input and returns an `Option[ExtendedPrivateKey]` or `Option[ExtendedPublicKey]` object, depending on whether the parent key is a private or public key.\n\n```scala\nval childKeyOpt = BIP32.derive(masterKey, 0)\n```\n\nThe `Mnemonic` object and its accompanying `Mnemonic` case class provide functionality for generating and validating mnemonic phrases, which are used to generate cryptographic keys for wallets. The `Mnemonic` case class represents a mnemonic phrase as a vector of words and provides methods for converting the phrase to a seed, which can be used to generate cryptographic keys.\n\n```scala\nval mnemonicOpt = Mnemonic.generate(24)\nmnemonicOpt.foreach { mnemonic =>\n  val seed = mnemonic.toSeed(Some(\"passphrase\"))\n  // use seed to generate cryptographic keys\n}\n```\n\nOverall, the `org.alephium.crypto.wallet` package provides a convenient and secure way to generate and manipulate HD wallets using the BIP32 standard and mnemonic phrases. It can be used in conjunction with other cryptocurrency libraries to implement wallet functionality in a larger project. For example, it could be used to generate a new address for each transaction in a cryptocurrency wallet application.",
  "questions": ""
}